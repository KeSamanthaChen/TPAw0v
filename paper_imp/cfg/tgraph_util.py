import copy
import numpy as np
import pygraphviz as pgv
import networkx as nx
from lean_cfg import CFGLean
from typing import List

"""
Convention:
tg: traced graph, the trace data is embedded to the graph as it is.
    This is extremely large typically, the branch order infor is preserved
cg: cost graph, generated by decorate_flow from a tg. The iterations & cost & flows 
    can be inquiried
"""

def remove_null(cg, inplace=True):
    """ remove unvisited node and unvisited edges """
    print('remove null')
    if not inplace:
        cg = duplicate(cg)
    unvisited = []
    for n in cg.nodes:
        if cg.nodes[n]['fin'] == 0 and cg.nodes[n]['fout'] == 0:
            unvisited.append(n)
    cg.remove_nodes_from(unvisited)

    null_edges = []
    for e in cg.edges:
        if cg.get_edge_data(*e)['cost'] == 0:
            null_edges.append(e)
    cg.remove_edges_from(null_edges)
    return cg

def duplicate(g):
    return copy.deepcopy(g)

def eval_edge_cost(edge, strips: List[str]):
    null_access = lambda xs: True if sum(x for x in xs) == 0 else False
    atom_count = []
    iterations = []
    for strip in strips:
        if 'flows' in edge[strip]:
            iterations.append(edge[strip]['flows'])
        else:
            iterations.append(len(edge[strip]))
            for key, val in edge[strip].items():
                atom_count.append(val)
    meta = {}
    # meta['g_flows'] = atom_count
    meta['iterations'] = iterations
    if not null_access(iterations):
        meta['g_min'] = min(atom_count)
        meta['g_max'] = max(atom_count)
        meta['g_mean'] = np.mean(atom_count)
        meta['g_std'] = np.std(atom_count)
        meta['min_mean_ratio'] = meta['g_min'] / meta['g_mean']
        meta['max_mean_ratio'] = meta['g_max'] / meta['g_mean']
    return meta

def collect(edge_data, key, strips):
    l = []
    for strip in strips:
        l.append(edge_data[strip][key])
    return l

def eval_edge_cost_unorder(edge_data, strips: List[str], g):
    iterations = collect(edge_data, 'flows', strips)
    maxs = collect(edge_data, 'atom_max', strips)
    mins = collect(edge_data, 'atom_min', strips)
    means = collect(edge_data, 'atom_mean', strips)
    stds = collect(edge_data, 'atom_std', strips)

    meta = derive_meta(iterations, maxs, mins, means, stds)
    return meta

def derive_meta(iterations, maxs, mins, means, stds):
    null_access = lambda xs: True if sum(x for x in xs) == 0 else False
    meta = {}
    meta['iterations'] = iterations
    # if not null_access(iterations):
    if not (0 in iterations):
        meta['g_min'] = min(mins)
        meta['g_max'] = max(maxs) 
        meta['g_mean'] = np.mean(means) 
        meta['g_std'] = np.mean(stds)
        meta['min_mean_ratio'] = meta['g_min'] / meta['g_mean']
        meta['max_mean_ratio'] = meta['g_max'] / meta['g_mean']
    return meta

def report_meta(g, strips):
    for u,v,data in g.edges(data=True):
        meta = eval_edge_cost(data, strips)
        print(f'\nEdge {u} -> {v}')
        for key, val in meta.items():
            print(f'{key}:{val}')
        

def decorate_flow(g, strips, optim = None, thresh_r = 0.5, order=False):
    print('decorate flow')
    null_access = lambda xs: True if sum(x for x in xs) == 0 else False
    for up, down, data in g.edges(data=True):
        if order:
            meta = eval_edge_cost(data, strips)
        else:
            meta = eval_edge_cost_unorder(data, strips, g)
        #if null_access(meta['iterations']): # null access is diff form not(0 in iter)
        if 0 in meta['iterations']: # null access is diff form not(0 in iter)
            g.edges[up,down]['cost'] = 0
            g.edges[up,down]['iters'] = [0]
        else:
            if meta['min_mean_ratio'] < thresh_r:
                print(f'WARNING EDGE COST: min/mean ratio low {meta["min_mean_ratio"]}')
                print(f'Min is {meta["g_min"]}')
            if meta['max_mean_ratio'] > 1 + thresh_r:
                print(f'WARNING EDGE COST: max/mean ratio high {meta["max_mean_ratio"]}')
                print(f'Max is {meta["g_max"]}')
            # g.edges[up,down]['cost'] = meta['g_mean'] 
            g.edges[up,down]['cost'] = meta['g_min']
            g.edges[up,down]['iters'] = meta['iterations']

    # next calculate flow conservation
    for n in g.nodes:
        fin, fout = get_node_total_flow(g, n, use='iters')
        g.nodes[n]['fin'] = fin
        g.nodes[n]['fout'] = fout
        g.nodes[n]['f_diff'] = fin - fout

    return g            

def get_node_total_flow(g, n, use='iters'):
    us = g.in_edges(n)
    vs = g.out_edges(n)
    fin = sum(g.get_edge_data(*u)[use][0] for u in us)
    fout = sum(g.get_edge_data(*v)[use][0] for v in vs)
    return fin, fout
    

def find_node(g, addr=None):
    if addr:
        for n in g.nodes:
            if n.has_addr(addr):
                return n
        print(f'Cannot find {addr} BB in g')



def report_cost(g):
    print("------------- Graph Edge Cost ------------------")
    for up,down,data in g.edges(data=True):
        print(f'    {up} {down} {data["cost"]}')
    print("-------------     End         ------------------")


def get_entry(g):
    for n in g.nodes:
        if g.in_degree(n) == 0:
            return n
    print("CRITICAL: cannot find entry node!")

def get_exit(g):
    exits = []
    for n in g.nodes:
        if g.out_degree(n) == 0:
            exits.append(n)
    assert len(exits) == 1, "Not handle multi-exit for now"
    return exits[0]

def visualize(g,fname='test.dot', label = 'full'):
    vg = pgv.AGraph(strict=False, directed=True)
    vg.node_attr['style'] = 'filled'
    vg.node_attr['shape'] = 'record'
    for n in list(g.nodes):
        texts = []
        texts.append(n.content_repr())
        metas = list( f'{key}:{val}' for key, val in g.nodes[n].items())
        texts = texts + metas
        texts = '\l'.join(texts)
        vg.add_node(n, label=texts)
        if 'visited' in g.nodes[n] and g.nodes[n]['visited']:
            vg.get_node(n).attr['color'] = "#def2de"
        if 'is_dom' in g.nodes[n] and g.nodes[n]['is_dom']:
            vg.get_node(n).attr['color'] = "#aaffee"
        if 'is_transient_mono' in g.nodes[n] and g.nodes[n]['is_transient_mono']:
            vg.get_node(n).attr['color'] = "#f79862"
        if 'is_2gd_transient_mono' in g.nodes[n] and g.nodes[n]['is_2gd_transient_mono']:
            vg.get_node(n).attr['color'] = "#d43f24"
        if 'is_ms' in g.nodes[n] and g.nodes[n]['is_ms']:
            vg.get_node(n).attr['color'] = "#ff7e7e"
    for e in list(g.edges):
        if label == 'full':
            text = str(g.get_edge_data(*e))
        elif isinstance(label, list):
            texts = []
            for l in label:
                texts.append(f'{l}:{str(g.edges[e][l])}')
            text = '\l'.join(texts)
        elif label is None:
            text = None
        else:
            text = g.edges[e][label]
        vg.add_edge(*e, label=text)
    vg.write(fname)

def visual_cost(g,label = ['cost','iters']):
    visualize(g, f'mser.t.dot', label = label)

def full2cost(g, inplace=True, strips = ['mser.strip']):
    if not inplace:
        g = duplicate(g)
    g = decorate_flow(g, strips)
    return g

def embed_dom(g):
    print('embedded dominance relation')
    nx.set_node_attributes(g, False, name='is_dom')
    chain = dom_chain(g)
    for node in chain:
        g.nodes[node]['is_dom'] = True
    return g

def dom_chain(g):
    entry = get_entry(g)
    leave = get_exit(g)

    d = nx.immediate_dominators(g, entry)
    chain = []
    while(leave is not entry):
        chain.append(leave)
        leave = d[leave]
    chain.reverse()
    return chain

def eval_iters(iters, mode='min'):
    """ Since across multiple sample traces. Each sample has a number of iteration
        on the edge, use the min across all for safety placement of MS"""
    if isinstance(iters, list):
        if len(iters) == 1:
            return iters[0]
        mean = np.mean(iters)
        mini, maxi = min(iters), max(iters)
        # assert mini > 0.5 * mean and maxi < 1.5 * mean, "safety check"
        if mode == 'min':
            return min(iters)
        elif mode == 'max':
            return max(iters)
        elif mode == 'mean':
            return np.mean(iters)
    else:
        return iters



